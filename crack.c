/*
    This source code is created and compiled for 2019 Semester 1 COMP30023
    Assignment 2. This is the submission version for the whole project.
    Author:         Qini Zhang
    Student Number: 901051
    Login Name:     qiniz
    Date:           May, 2019
*/

/***************************** HEADER FILES ***********************************/
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <time.h>
#include "sha256.h"

/******************************** MACROS **************************************/
#define MAX_WORD_SIZE 200

// do not change it, otherwise test 2 with 2-argu will fail
#define PWD_LEN 4
#define PWD6_INDEX 11

// frequency generated, for more information, please refer to count_freq.py

//    -- using candidate_char_1[] find there is no uppercase char in pwd6 set:
//    -- all lower case alphabet
static const char candidate_char_1[] = 
                    "earonistlcdmhgbupykfwvjzxq";

/*    -- using candidate_char_2[] find there is no pure number in pwd6 set:
static const char candidate_char_2[] = 
                    "earonistlcdmhgbupykfwvjzxq 1230459678";

// -- using candidate_char_3[] find 14 passwords in pwd6 set:
static const char candidate_char_3[] = 
                    "GEMROABCDFHIJKLNPQSTUVWXYZ 1230459678";
*/

// then comes out good guess set: only contains lower case alphabetic char, 
// numbers and high frequency special character generated by count_freq.py:
static const char candidate_char_4[] = 
                    "earonistlcdmhgbupy1kfwv2j3z0459x678q*?.+&-C!GE\\;MRO\' ";

/************************** Function Prototypes *******************************/
void crack_with_two(const char *pwd_file, 
                unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], int nitem);

void compare_with_sha256(char* word,
        unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], int nitem, int index);

void good_guess(unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], int nitem, 
                                                    int mode, int num_guess);

void crack_with_one(int num_guess);

void smart_brute_force_6_pwd(unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], 
                                int nitem, const char* dic);

void smart_brute_force_4_pwd(unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], 
                                int nitem, const char* dic);

void print_smart_brute_force_6_pwd(const char* dic, int count, int num_guess);
/******************************************************************************/

/*
    num_guess: how many guesses it should produce. this number of password 
               guesses should be printed to stdout, separated by newline 
               characters (`\n').
*/
void crack_with_one(int num_guess){
    // crack_with_one((int)argv[1], sha256_list, nitem);
    int count = 0;

    // first start dic attack:
    FILE *word_file = fopen("filtered_commom_list.txt", "r");

    char word[MAX_WORD_SIZE];
    while(fgets(word, MAX_WORD_SIZE, word_file)!=NULL){
        // if there's "\n" contain in text file, then ignore it
        strtok(word, "\n");

        if(count < num_guess){
            printf("%s\n", word);
            count++;
        }else{
            return;
        }
    }
    // when exhausted dictionary, then generate by smart bruce force:
    // here's 4-passwords example:
    print_smart_brute_force_6_pwd(candidate_char_4, count, num_guess-1); 
}

/*
    Test each of the passwords against each of the hashes, 
    and produce output as for the case of no arguments. 

    pwd_file:    filename of a list of passwords (one per line), 
    sha256_file: filename of a list of SHA256 hashes (in groups of 32 bytes, 
                 with no newline characters). 
*/ 
void crack_with_two(const char *pwd_file, 
                    unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], int nitem){
    // processing with candicate word:
    FILE *word_file = fopen(pwd_file, "r");
    char word[MAX_WORD_SIZE];
    while(fgets(word, MAX_WORD_SIZE, word_file)!=NULL){
        // if there's "\n" contain in text file, then ignore it
        strtok(word, "\n");
        if(PWD_LEN == 4){
            compare_with_sha256(word, sha256_list, nitem, 1);
        }else if(PWD_LEN == 6){
            compare_with_sha256(word, sha256_list, nitem, PWD6_INDEX);
        }
    }
}

/*
    compare word with the sha256 file

    word:           each word in the candidate wordlist file
    sha256_list:    after read sha256 file and put them into a 2Darray,
                    which length is the number of contain pwd (10 in pwd_4 case)
                    and each pwd is 32 bytes
*/
void compare_with_sha256(char* word, 
        unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], int nitem, int index){
    BYTE buf[SHA256_BLOCK_SIZE];
    SHA256_CTX ctx;

    sha256_init(&ctx);
    sha256_update(&ctx, (BYTE*)word, strlen(word));
	sha256_final(&ctx, buf);
    
    for(int i=0; i<nitem; i++){
        if(memcmp(sha256_list[i], buf, SHA256_BLOCK_SIZE) == 0){
            printf("%s %d\n", word, i+index);
        }
    }
}

/*
    after using stupid brute force, the result from decryption passwords show
    that all my pwd4sha256 made from alphabetic. 

    N.B: just for my case of pwd4sha256! -> just use 3s!!
*/
void smart_brute_force_4_pwd(unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], 
                                int nitem, const char* dic){
    char guess_pwd[5];
    guess_pwd[4] = '\0';
    int len = strlen(dic);
    for(int i=0; i<len; i++){
        for(int j=0; j<len; j++){
            for(int k=0; k<len; k++){
                for(int l=0; l<len; l++){
                    guess_pwd[0] = dic[i];
                    guess_pwd[1] = dic[j];
                    guess_pwd[2] = dic[k];
                    guess_pwd[3] = dic[l];
                    compare_with_sha256(guess_pwd, sha256_list, nitem, 1);
                }
            }
        }
    }
}

/*
    this function made for crack_with_one, 
    to print words without compare with sha256

    int count:       count the number of print words
    int num_guess:   the input number of crack(1), the number of words needs to 
                     be generated.
*/
void print_smart_brute_force_6_pwd(const char* dic, int count, int num_guess){
    char guess_pwd[7];
    guess_pwd[6] = '\0';
    int len = strlen(dic);
    for(int i=0; i<len; i++){
        for(int j=0; j<len; j++){
            for(int k=0; k<len; k++){
                for(int l=0; l<len; l++){
                    for(int m=0; m<len; m++){
                        for(int n=0; n<len; n++){
                            guess_pwd[0] = dic[i];
                            guess_pwd[1] = dic[j];
                            guess_pwd[2] = dic[k];
                            guess_pwd[3] = dic[l];
                            guess_pwd[4] = dic[m];
                            guess_pwd[5] = dic[n];
                            if(count < num_guess){
                                printf("%s\n", guess_pwd);
                                count++;
                            }else{
                                return;
                            }
                        }
                    }
                }
            }
        }
    }
}

void smart_brute_force_6_pwd(unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], 
                                int nitem, const char* dic){
    char guess_pwd[7];
    guess_pwd[6] = '\0';
    int len = strlen(dic);
    for(int i=0; i<len; i++){
        for(int j=0; j<len; j++){
            for(int k=0; k<len; k++){
                for(int l=0; l<len; l++){
                    for(int m=0; m<len; m++){
                        for(int n=0; n<len; n++){
                            guess_pwd[0] = dic[i];
                            guess_pwd[1] = dic[j];
                            guess_pwd[2] = dic[k];
                            guess_pwd[3] = dic[l];
                            guess_pwd[4] = dic[m];
                            guess_pwd[5] = dic[n];
                            // crack with no argument:
                            compare_with_sha256(guess_pwd, sha256_list,
                                                        nitem, PWD6_INDEX);
                        }
                    }
                }
            }
        }
    }
}

/*
    My good guess approach:
    1. first run common-word list (dictionary attack) 
        -> get 4 passwords
        -> total 4 pwds
    2. then use smart brute force. From the observation of the pwd4sha256 
    decryption, togetther with counting character's frequency of 
    "commom_password.txt", it's easy to found the way of smart brute force:
                    -- smart brute force: 
                    step 1: all generate by lower case abt
                                -> get 11 passwords, include 3 from common list
                                -> takes 190s, total 12 pwds
                                -> reach the requirment!!
                    step 2: number together with lower case:
                                -> get extra 3 passwords, include 2 from comlist
                                -> takes 1000s, total 13 pwds
                    step 3: use whole frequency list (generate by count_freq.py)
                                -> get 3 more
                                -> takes 5500s, total 16 pwds
*/
void good_guess(unsigned char sha256_list[][SHA256_BLOCK_SIZE+1], int nitem, int mode, int num_guess){
    // first run commom wordlist (dictionary attack), 
    // filtered using count_freq.py
    if(mode == 1){
        crack_with_two("filtered_commom_list.txt", sha256_list, nitem);
        // then go smart brute force:
        if(PWD_LEN == 4){
            smart_brute_force_4_pwd(sha256_list, nitem, candidate_char_1);
        }
        else if(PWD_LEN == 6){
            // step 1: already reach the requirment, 
            // prefer not to continue the rest of the steps
            smart_brute_force_6_pwd(sha256_list, nitem, candidate_char_1);
            // step 2
            // smart_brute_force_6_pwd(sha256_list, nitem, candidate_char_2);
            // step 3
            // smart_brute_force_6_pwd(sha256_list, nitem, candidate_char_2);
        }
    }else if(mode == 2){
        crack_with_one(num_guess);
    }
}

/*************************** MAIN FUNCTION ************************************/

int main(int argc, char* argv[]){
    // processing with sha256 file just for init:
    char* sha256_file="pwd4sha256";

    // when crack with argument one, just generate pwds:
    if(argc == 2){
        int num_guess = atoi(argv[1]);
        good_guess(NULL, 0, 2, num_guess);
    }
    else{
        // decide which pwdsha256 to use -> based on #define:
        if(argc == 1){
            if(PWD_LEN == 4){
                sha256_file = "pwd4sha256";
            }else if(PWD_LEN == 6){
                sha256_file = "pwd6sha256";
            }
        }else{
            if(argc == 3){
                sha256_file = argv[2];
            }else if(argc > 2){
                fprintf(stderr, "ERROR: too many argument!");
            }
        }
        // processing the sha256 file:
        FILE *fl = fopen(sha256_file, "r");  
        fseek(fl, 0, SEEK_END);  
        long len = ftell(fl); 
        int nitem = len/SHA256_BLOCK_SIZE;
        
        // using variable length array to store 
        unsigned char sha256_list[nitem][SHA256_BLOCK_SIZE+1]; 

        fseek(fl, 0, SEEK_SET); 
        for(int i=0; i<nitem; i++){
            if(fread(sha256_list[i], SHA256_BLOCK_SIZE, 1, fl) == 0){
                break;
            }
        } 

        // when crack with no argument:
        if(argc == 1){
            clock_t begin = clock();
            good_guess(sha256_list, nitem, 1, 0);
            clock_t end = clock();
            double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
            printf("time: %f sec\n", time_spent);
        }

        // when crack with two arguments:
        else if(argc == 3){
            crack_with_two(argv[1], sha256_list, nitem);
        }
    
        // close file
        fclose(fl); 
    }
}
